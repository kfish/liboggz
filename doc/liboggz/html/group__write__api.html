<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>liboggz: OGGZ Write API</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">Globals</a></div>
<h1>OGGZ Write API</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
OGGZ maintains a packet queue, such that you can independently add packets to the queue and write an Ogg bitstream. 
<p>
There are two complementary methods for adding packets to the packet queue.<p>
<ul>
<li>by <a class="el" href="group__force__feed.html">force feeding OGGZ </a></li><li>by using <a class="el" href="group__hungry.html">OggzHungry </a> callbacks</li></ul>
<p>
As each packet is enqueued, its validity is checked against the framing constraints outlined in the <a class="el" href="group__basics.html">Ogg basics </a> section. If it does not pass these constraints, <a class="el" href="group__write__api.html#a2">oggz_write_feed()</a> will fail with an appropriate error code.<p>
<dl compact><dt><b>Note:</b></dt><dd><ul>
<li>When writing, you can ensure that a packet starts on a new page by setting the <em>flush</em> parameter of <a class="el" href="group__write__api.html#a2">oggz_write_feed()</a> to <em>OGGZ_FLUSH_BEFORE</em> when enqueuing it. Similarly you can ensure that the last page a packet is written into won't contain any following packets by setting the <em>flush</em> parameter of <a class="el" href="group__write__api.html#a2">oggz_write_feed()</a> to <em>OGGZ_FLUSH_AFTER</em>.</li><li>The <em>OGGZ_FLUSH_BEFORE</em> and <em>OGGZ_FLUSH_AFTER</em> flags can be bitwise OR'd together to ensure that the packet will not share any pages with any other packets, either before or after. </li></ul>
</dd></dl>

<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>typedef int(*&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__write__api.html#a0">OggzWriteHungry</a> )(<a class="el" href="oggz_8h.html#a0">OGGZ</a> *oggz, int empty, void *user_data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is the signature of a callback which Oggz will call when <em>oggz</em> is <a class="el" href="group__hungry.html">hungry </a>. </em> <a href="#a0"></a><em><br><br></td></tr>
<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__write__api.html#a1">oggz_write_set_hungry_callback</a> (<a class="el" href="oggz_8h.html#a0">OGGZ</a> *oggz, <a class="el" href="oggz_8h.html#a0">OggzWriteHungry</a> hungry, int only_when_empty, void *user_data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a callback for Oggz to call when <em>oggz</em> is <a class="el" href="group__hungry.html">hungry </a>. </em> <a href="#a1"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__write__api.html#a2">oggz_write_feed</a> (<a class="el" href="oggz_8h.html#a0">OGGZ</a> *oggz, ogg_packet *op, long serialno, int flush, int *guard)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a packet to <em>oggz's</em> packet queue. </em> <a href="#a2"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>long&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__write__api.html#a3">oggz_write_output</a> (<a class="el" href="oggz_8h.html#a0">OGGZ</a> *oggz, unsigned char *buf, long n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Output data from an OGGZ handle. </em> <a href="#a3"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>long&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__write__api.html#a4">oggz_write</a> (<a class="el" href="oggz_8h.html#a0">OGGZ</a> *oggz, long n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write n bytes from an OGGZ handle. </em> <a href="#a4"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>long&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__write__api.html#a5">oggz_write_get_next_page_size</a> (<a class="el" href="oggz_8h.html#a0">OGGZ</a> *oggz)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Query the number of bytes in the next page to be written. </em> <a href="#a5"></a><em><br><br></td></tr>
</table>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="a0" doxytag="oggz.h::OggzWriteHungry" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef int(* <a class="el" href="oggz_8h.html#a0">OggzWriteHungry</a>)(<a class="el" href="oggz_8h.html#a0">OGGZ</a> * oggz, int empty, void * user_data)
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This is the signature of a callback which Oggz will call when <em>oggz</em> is <a class="el" href="group__hungry.html">hungry </a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>oggz</em>&nbsp;</td><td>The OGGZ handle </td></tr>
    <tr><td valign=top><em>empty</em>&nbsp;</td><td>A value of 1 indicates that the packet queue is currently empty. A value of 0 indicates that the packet queue is not empty. </td></tr>
    <tr><td valign=top><em>user_data</em>&nbsp;</td><td>A generic pointer you have provided earlier </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>0</em>&nbsp;</td><td>Continue </td></tr>
    <tr><td valign=top><em>non-zero</em>&nbsp;</td><td>Instruct OGGZ to stop. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="a4" doxytag="oggz.h::oggz_write" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> long oggz_write </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="oggz_8h.html#a0">OGGZ</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>oggz</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>long&nbsp;</td>
          <td class="mdname" nowrap> <em>n</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Write n bytes from an OGGZ handle. 
<p>
Oggz will call your write callback as needed.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>oggz</em>&nbsp;</td><td>An OGGZ handle previously opened for writing </td></tr>
    <tr><td valign=top><em>n</em>&nbsp;</td><td>A count of bytes to be written </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>&gt; 0</em>&nbsp;</td><td>The number of bytes successfully output </td></tr>
    <tr><td valign=top><em>0</em>&nbsp;</td><td>End of stream </td></tr>
    <tr><td valign=top><em>OGGZ_ERR_RECURSIVE_WRITE</em>&nbsp;</td><td>Attempt to initiate writing from within an OggzHungry callback </td></tr>
    <tr><td valign=top><em>OGGZ_ERR_BAD_OGGZ</em>&nbsp;</td><td><em>oggz</em> does not refer to an existing OGGZ </td></tr>
    <tr><td valign=top><em>OGGZ_ERR_INVALID</em>&nbsp;</td><td>Operation not suitable for this OGGZ </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a2" doxytag="oggz.h::oggz_write_feed" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int oggz_write_feed </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="oggz_8h.html#a0">OGGZ</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>oggz</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>ogg_packet *&nbsp;</td>
          <td class="mdname" nowrap> <em>op</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>long&nbsp;</td>
          <td class="mdname" nowrap> <em>serialno</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>flush</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>guard</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Add a packet to <em>oggz's</em> packet queue. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>oggz</em>&nbsp;</td><td>An OGGZ handle previously opened for writing </td></tr>
    <tr><td valign=top><em>op</em>&nbsp;</td><td>An ogg_packet with all fields filled in </td></tr>
    <tr><td valign=top><em>serialno</em>&nbsp;</td><td>Identify the logical bitstream in <em>oggz</em> to add the packet to </td></tr>
    <tr><td valign=top><em>flush</em>&nbsp;</td><td>Bitmask of OGGZ_FLUSH_BEFORE, OGGZ_FLUSH_AFTER </td></tr>
    <tr><td valign=top><em>guard</em>&nbsp;</td><td>A guard for nocopy, NULL otherwise </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>0</em>&nbsp;</td><td>Success </td></tr>
    <tr><td valign=top><em>OGGZ_ERR_BAD_GUARD</em>&nbsp;</td><td><em>guard</em> specified has non-zero initialization </td></tr>
    <tr><td valign=top><em>OGGZ_ERR_BOS</em>&nbsp;</td><td>Packet would be bos packet of a new logical bitstream, but oggz has already written one or more non-bos packets in other logical bitstreams, and <em>oggz</em> is not flagged OGGZ_NONSTRICT </td></tr>
    <tr><td valign=top><em>OGGZ_ERR_EOS</em>&nbsp;</td><td>The logical bitstream identified by <em>serialno</em> is already at eos, and <em>oggz</em> is not flagged OGGZ_NONSTRICT </td></tr>
    <tr><td valign=top><em>OGGZ_ERR_BAD_BYTES</em>&nbsp;</td><td><em>op-&gt;bytes</em> is invalid, and <em>oggz</em> is not flagged OGGZ_NONSTRICT </td></tr>
    <tr><td valign=top><em>OGGZ_ERR_BAD_B_O_S</em>&nbsp;</td><td><em>op-&gt;b_o_s</em> is invalid, and <em>oggz</em> is not flagged OGGZ_NONSTRICT </td></tr>
    <tr><td valign=top><em>OGGZ_ERR_BAD_GRANULEPOS</em>&nbsp;</td><td><em>op-&gt;granulepos</em> is less than that of an earlier packet within this logical bitstream, and <em>oggz</em> is not flagged OGGZ_NONSTRICT </td></tr>
    <tr><td valign=top><em>OGGZ_ERR_BAD_PACKETNO</em>&nbsp;</td><td><em>op-&gt;packetno</em> is less than that of an earlier packet within this logical bitstream, and <em>oggz</em> is not flagged OGGZ_NONSTRICT </td></tr>
    <tr><td valign=top><em>OGGZ_ERR_BAD_SERIALNO</em>&nbsp;</td><td><em>serialno</em> does not identify an existing logical bitstream in <em>oggz</em>, and <em>oggz</em> is not flagged OGGZ_NONSTRICT </td></tr>
    <tr><td valign=top><em>OGGZ_ERR_BAD_OGGZ</em>&nbsp;</td><td><em>oggz</em> does not refer to an existing OGGZ </td></tr>
    <tr><td valign=top><em>OGGZ_ERR_INVALID</em>&nbsp;</td><td>Operation not suitable for this OGGZ</td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>If <em>op-&gt;b_o_s</em> is initialized to <em>-1</em> before calling <a class="el" href="group__write__api.html#a2">oggz_write_feed()</a>, Oggz will fill it in with the appropriate value; ie. 1 for the first packet of a new stream, and 0 otherwise. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a5" doxytag="oggz.h::oggz_write_get_next_page_size" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> long oggz_write_get_next_page_size </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="oggz_8h.html#a0">OGGZ</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>oggz</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Query the number of bytes in the next page to be written. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>oggz</em>&nbsp;</td><td>An OGGZ handle previously opened for writing </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>&gt;= 0</em>&nbsp;</td><td>The number of bytes in the next page </td></tr>
    <tr><td valign=top><em>OGGZ_ERR_BAD_OGGZ</em>&nbsp;</td><td><em>oggz</em> does not refer to an existing OGGZ </td></tr>
    <tr><td valign=top><em>OGGZ_ERR_INVALID</em>&nbsp;</td><td>Operation not suitable for this OGGZ </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a3" doxytag="oggz.h::oggz_write_output" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> long oggz_write_output </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="oggz_8h.html#a0">OGGZ</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>oggz</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned char *&nbsp;</td>
          <td class="mdname" nowrap> <em>buf</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>long&nbsp;</td>
          <td class="mdname" nowrap> <em>n</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Output data from an OGGZ handle. 
<p>
Oggz will call your write callback as needed.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>oggz</em>&nbsp;</td><td>An OGGZ handle previously opened for writing </td></tr>
    <tr><td valign=top><em>buf</em>&nbsp;</td><td>A memory buffer </td></tr>
    <tr><td valign=top><em>n</em>&nbsp;</td><td>A count of bytes to output </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>&gt; 0</em>&nbsp;</td><td>The number of bytes successfully output </td></tr>
    <tr><td valign=top><em>0</em>&nbsp;</td><td>End of stream </td></tr>
    <tr><td valign=top><em>OGGZ_ERR_RECURSIVE_WRITE</em>&nbsp;</td><td>Attempt to initiate writing from within an OggzHungry callback </td></tr>
    <tr><td valign=top><em>OGGZ_ERR_BAD_OGGZ</em>&nbsp;</td><td><em>oggz</em> does not refer to an existing OGGZ </td></tr>
    <tr><td valign=top><em>OGGZ_ERR_INVALID</em>&nbsp;</td><td>Operation not suitable for this OGGZ </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a1" doxytag="oggz.h::oggz_write_set_hungry_callback" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int oggz_write_set_hungry_callback </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="oggz_8h.html#a0">OGGZ</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>oggz</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="oggz_8h.html#a0">OggzWriteHungry</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>hungry</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>only_when_empty</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>user_data</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set a callback for Oggz to call when <em>oggz</em> is <a class="el" href="group__hungry.html">hungry </a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>oggz</em>&nbsp;</td><td>An OGGZ handle previously opened for writing </td></tr>
    <tr><td valign=top><em>hungry</em>&nbsp;</td><td>Your callback function </td></tr>
    <tr><td valign=top><em>only_when_empty</em>&nbsp;</td><td>When to call: a value of 0 indicates that OGGZ should call <em>hungry()</em> after each and every packet is written; a value of 1 indicates that OGGZ should call <em>hungry()</em> only when its packet queue is empty </td></tr>
    <tr><td valign=top><em>user_data</em>&nbsp;</td><td>Arbitrary data you wish to pass to your callback </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>0</em>&nbsp;</td><td>Success </td></tr>
    <tr><td valign=top><em>OGGZ_ERR_BAD_OGGZ</em>&nbsp;</td><td><em>oggz</em> does not refer to an existing OGGZ </td></tr>
    <tr><td valign=top><em>OGGZ_ERR_INVALID</em>&nbsp;</td><td>Operation not suitable for this OGGZ </td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>Passing a value of 0 for <em>only_when_empty</em> allows you to feed new packets into <em>oggz's</em> packet queue on the fly. </dd></dl>
    </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Wed Jan 21 15:05:41 2004 for liboggz by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
